const { PrismaClient } = require('@prisma/client');
const bcrypt = require('bcrypt');

const prisma = new PrismaClient();

// Get all users
exports.getAllUsers = async (req, res) => {
  try {
    const users = await prisma.user.findMany({
      include: {
        assignedTickets: {
          select: {
            id: true,
            status: true
          }
        }
      },
      orderBy: {
        name: 'asc'
      }
    });

    const usersWithStats = users.map(user => ({
      ...user,
      activeTickets: user.assignedTickets.filter(t => t.status !== 'Closed').length,
      totalTickets: user.assignedTickets.length
    }));

    res.json({
      success: true,
      users: usersWithStats
    });
  } catch (error) {
    console.error('Get users error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch users',
      error: error.message
    });
  }
};

// Get single user
exports.getUserById = async (req, res) => {
  try {
    const { id } = req.params;

    const user = await prisma.user.findUnique({
      where: { id },
      include: {
        assignedTickets: {
          orderBy: {
            createdAt: 'desc'
          }
        }
      }
    });

    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }

    const { password, ...userWithoutPassword } = user;

    res.json({
      success: true,
      user: userWithoutPassword
    });
  } catch (error) {
    console.error('Get user error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch user',
      error: error.message
    });
  }
};

// Create user
exports.createUser = async (req, res) => {
  try {
    const { name, email, password, role, department } = req.body;

    if (!name || !email || !password) {
      return res.status(400).json({
        success: false,
        message: 'Name, email, and password are required'
      });
    }

    const username = email.split('@')[0];

    const existingUser = await prisma.user.findFirst({
      where: {
        OR: [
          { email },
          { username }
        ]
      }
    });

    if (existingUser) {
      return res.status(400).json({
        success: false,
        message: 'User with this email or username already exists'
      });
    }

    const hashedPassword = await bcrypt.hash(password, 10);

    const user = await prisma.user.create({
      data: {
        name,
        email,
        username,
        password: hashedPassword,
        role: role || 'staff',
        department: department && department.trim() ? department.trim() : null
      }
    });

    const { password: _, ...userWithoutPassword } = user;

    res.status(201).json({
      success: true,
      message: 'User created successfully',
      user: userWithoutPassword
    });
  } catch (error) {
    console.error('Create user error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to create user',
      error: error.message
    });
  }
};

// Update user
exports.updateUser = async (req, res) => {
  try {
    const { id } = req.params;
    const { name, email, role, department, password } = req.body;

    const existingUser = await prisma.user.findUnique({
      where: { id }
    });

    if (!existingUser) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }

    if (email && email !== existingUser.email) {
      const emailTaken = await prisma.user.findUnique({
        where: { email }
      });

      if (emailTaken) {
        return res.status(400).json({
          success: false,
          message: 'Email is already in use'
        });
      }
    }

    const updateData = {
      name,
      email,
      role,
      department: department && department.trim() ? department.trim() : null
    };

    if (email) {
      updateData.username = email.split('@')[0];
    }

    if (password) {
      updateData.password = await bcrypt.hash(password, 10);
    }

    const user = await prisma.user.update({
      where: { id },
      data: updateData
    });

    const { password: _, ...userWithoutPassword } = user;

    res.json({
      success: true,
      message: 'User updated successfully',
      user: userWithoutPassword
    });
  } catch (error) {
    console.error('Update user error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to update user',
      error: error.message
    });
  }
};

// Delete user
exports.deleteUser = async (req, res) => {
  try {
    const { id } = req.params;

    const user = await prisma.user.findUnique({
      where: { id },
      include: {
        assignedTickets: {
          where: {
            status: {
              notIn: ['Closed', 'Resolved']
            }
          }
        }
      }
    });

    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }

    if (user.assignedTickets.length > 0) {
      return res.status(400).json({
        success: false,
        message: `Cannot delete user with ${user.assignedTickets.length} active assigned tickets. Please reassign or close tickets first.`
      });
    }

    await prisma.user.delete({
      where: { id }
    });

    res.json({
      success: true,
      message: 'User deleted successfully'
    });
  } catch (error) {
    console.error('Delete user error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to delete user',
      error: error.message
    });
  }
};

// Bulk import users from CSV
exports.bulkImportUsers = async (req, res) => {
  try {
    const users = req.body.users;

    if (!users || !Array.isArray(users) || users.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'No user data provided'
      });
    }

    const results = {
      success: [],
      failed: []
    };

    for (const userData of users) {
      try {
        const { name, email, password, role, departmentname } = userData;

        if (!name || !email || !password) {
          results.failed.push({
            email: email || 'unknown',
            reason: 'Missing required fields (name, email, or password)'
          });
          continue;
        }

        const username = email.trim().toLowerCase().split('@')[0];

        const existingUser = await prisma.user.findFirst({
          where: {
            OR: [
              { email: email.trim().toLowerCase() },
              { username }
            ]
          }
        });

        if (existingUser) {
          results.failed.push({
            email,
            reason: 'User already exists'
          });
          continue;
        }

        const hashedPassword = await bcrypt.hash(password, 10);

        // Process department - trim and convert to null if empty
        let departmentValue = null;
        if (departmentname && typeof departmentname === 'string') {
          const trimmed = departmentname.trim();
          if (trimmed && trimmed.toLowerCase() !== 'null' && trimmed.toLowerCase() !== 'undefined') {
            departmentValue = trimmed;
          }
        }

        const user = await prisma.user.create({
          data: {
            name: name.trim(),
            email: email.trim().toLowerCase(),
            username,
            password: hashedPassword,
            role: role && role.trim() ? role.trim().toLowerCase() : 'staff',
            department: departmentValue
          }
        });

        results.success.push({
          email: user.email,
          name: user.name,
          department: user.department
        });

      } catch (error) {
        results.failed.push({
          email: userData.email || 'unknown',
          reason: error.message
        });
      }
    }

    res.json({
      success: true,
      message: `Import completed: ${results.success.length} users created, ${results.failed.length} failed`,
      results
    });

  } catch (error) {
    console.error('Bulk import error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to import users',
      error: error.message
    });
  }
};

module.exports = exports;
